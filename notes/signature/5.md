---
layout: linear
date: 17 March 2022
title: âˆƒCM Secure Schemes
preamble: |-
    \newcommand{\gen}{\texttt{gen}}
    \newcommand{\sgn}{\texttt{sgn}}
    \newcommand{\vrf}{\texttt{vrf}}
    \newcommand{\ECM}{\exists\textrm{CM}}
returnPage: ./
---

Utilising any one-time secure scheme as blackbox, constructions of $$\ECM$$ secure schemes are just metres away.
Let $$\Sigma = (\gen,\sgn,\vrf)$$ be any $$\ECM^1$$ secure scheme. We will begin with contructing a transparent $$\ECM_q$$ scheme $$\Sigma' := (\gen',\sgn',\vrf')$$ which basically runs $$q$$ independent copies of $$\Sigma$$. Sadly its public key is too long for practical deployment. We shall then progressively improve the key length using the notions of hash functions and Merkle trees.

# A Transparent Scheme

![](./5-long-pk.svg){:.centering}

**Exercise.**
Prove its soundness and $$\ECM_q$$ security.

In practical applications, we need to distribute/broadcast $$pk$$ safely to the public domain. This is a costly job in every aspects, so a much shorter key length, ideally independent of $$q$$, is desirable.

# Publish Keys on Demand

Observe that the $$i$$-th signing/verifying depends only on $$(sk_i, pk_i)$$, so it appears unnecessary to publish the entire public key bundle in the beginning. Can we publish the $$pk_i$$ on demand, say attaching it only when the $$i$$-th signature is requested?

![](./5-no-pk.svg){:.centering}

The scheme is sound but not at all secure! Philosophically, since we did not give away any public information, the verifier of course could not distinguish authetic and fake signatures. Concretely, a forger could generate himself any key pair $$(sk^*,pk^*)$$ and forge $$(m, pk^* \Vert \sgn(sk^*,m))$$. By doing so, he fools the verifier to use a wrong public key.

To fix this critical bug, we make use of *hash functions* that generates a "checksum".




# Hit the Balance: Merkle Trees


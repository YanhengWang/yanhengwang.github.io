---
layout: linear
date: 10 March 2022
title: One-Time Secure Schemes
preamble: |-
    \newcommand{\gen}{\texttt{gen}}
    \newcommand{\sgn}{\texttt{sgn}}
    \newcommand{\vrf}{\texttt{vrf}}
    \newcommand{\ECM}{\exists\textsf{CM}}
returnPage: ./
---

As a preliminary step towards our ultimate goal, we define a significantly weakened attack protocol.

**Definition.**
The *$$\ECM_1^-$$ (one-time chosen message) attack protocol* on signature scheme $$\Sigma = (\gen, \sgn, \vrf)$$ is given by

![](./4-ECM-1.svg){:.centering}

Clearly it is the restriction of $$\ECM^-$$ when $$l := 1$$, thus $$\ECM_1^- \leq \ECM^-$$.

We will give three different constructions of $$\ECM_1^-$$ secure schemes, based on different complexity assumptions.

# Construction Based on One-Way Functions

Assume $$f:\set{0,1}^* \to \set{0,1}^*$$ is any one-way function. We design the following signature scheme (known as Lamport's generic scheme) with message space $$\set{0,1}^k$$.

![](./4-Lamport.svg){:.centering}

We remind the reader that each key contains $$2k$$ *strings*, not *bits*.

The scheme is obviously sound, and now we argue about its security.  Let $$A$$ be any $$\ECM_1^-$$ adversary. Since it could request signature for merely one message $$m^\circ \in \set{0,1}^k$$, only half of the $$2k$$ secret strings are revealed. In order to forge signature for some $$m := c_1 \Vert c_2 \Vert \dots \Vert c_k \neq m^\circ$$, the adversary must correctly compute at least one *unrevealed* secret string, say $$r_i^{c_i}$$. This in effect inverts the function image $$f_i^{c_i}$$, which is hard since $$f$$ is one-way.

The foregoing argument is basically correct, but the last sentence needs elaboration. Recall that in the inversion attack protocol, we as an inverter is given a single random image to be inverted. But for the signature scheme adversary, on the other hand, he may choose his *preferred* one of the $$k$$ (unrevealed) images to invert. He might always choose the first string, or the fifth string, or a random one, but we don't really know. We cannot even assume that the adversary is willing to cooperate with our goal of inversion. He might even counter our effort. So we must cunningly trick the adversary into our game. This is done by hiding the image to be inverted at a *random position* of the key:

![](./4-Lamport-secure.svg){:.centering}

Here we emulate a $$\ECM_1^-$$ judge for the adversary $$A$$ even though we have no idea about the real preimage of $$f^{1-b_j}_j$$. Our ignorance will not be caught since the signature of $$m^\circ$$ does not use $$r^{1-b_j}_j$$. Hence, from the perspective of the adversary, everything goes smoothly as expected. He submits a valid forgery $$(m,\sigma)$$ with the same probability $$P_A$$ as in the real attack protocol.

Conditioned on $$(m,\sigma)$$ valid, we have

$$ c_1 \Vert c_2 \Vert \dots \Vert c_k := m \neq m^\circ =: b_1 \Vert b_2 \Vert \dots \Vert b_k, $$

so there is at least one bit difference. Observe that $$j$$ is independent of $$pk,\sigma^\circ$$ (why?) and consequently independent of $$(m,\sigma)$$ as well, so it is still uniformly distributed on $$[k]$$ under the condition. Hence $$\Pr(c_j \neq b_j \mid (m,\sigma) \text{ valid}) \geq 1/k$$.

If both the forgery is valid and $$c_j \neq b_j$$, then we know

$$ s_j = r_j^{c_j} \quad \text{and} \quad f(r_j^{c_j}) = f(r_j^{1-b_j}) = J.y, $$

meaning that the inversion succeeds. Therefore, $$\Pr(J \text{ returns true}) \geq P_A / k$$. But the LHS is negligible by definition of one-way function, so we conclude that $$P_A$$ is negligible. âˆŽ


# Construction Based on Discrete Logarithm

![](./4-dlog.svg){:.centering}

# Construction Based on RSA

![](./4-RSA.svg){:.centering}
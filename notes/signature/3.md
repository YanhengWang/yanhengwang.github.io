---
layout: linear
date: 10 March 2022
title: One-Way Functions
preamble: |-
    \newcommand{\gen}{\texttt{gen}}
    \newcommand{\sgn}{\texttt{sgn}}
    \newcommand{\vrf}{\texttt{vrf}}
    \newcommand{\ECM}{\exists\textsf{CM}}
returnPage: ./
---

As its name suggests, a one-way function is easy to evaluate but hard to invert.

**Definition.**
Let $$f: \set{0,1}^* \to \set{0,1}^*$$ be a polynomial-time computable function. Consider the *inversion attack protocol*:

![](./3-inversion-attack.svg){:.centering}

If for all polynomial-time randomised algorithms implementing $$I$$, the success probability $$\Pr(J \text{ returns true})$$ is negligible, then we call $$f$$ a *one-way function*. Here the "polynomial-time" and "negligible" are both measured with respect to the parameter $$k$$.

It is possible that for some particular image $$y$$ the inverter could quickly answer a correct preimage $$x: y = f(x)$$, but the point here is that he cannot handle a general random image derived from an exponentially large domain.

People believe that one-way functions do exist and there are multiple candidates in the market. However, proofs are still out of current reach, especially in view of the following theorem:

**Theorem 3.**
If one-way function exists, then P ≠ NP.

*Proof.*
Let $$f: \set{0,1}^* \to \set{0,1}^*$$ be a one-way function. For binary strings $$t,x \in \set{0,1}^*$$, we denote $$t \sqsubseteq x$$ if $$t$$ is a prefix of $$x$$. Consider the language

$$L := \set{(1^\ell,t,y) ~\middle\vert~ \exists x \in \set{0,1}^\ell: t \sqsubseteq x \land f(x)=y}.$$

It is easy to see $$L \in \mathrm{NP}$$. This is because $$(1^\ell,t,y) \in L$$ iff there exists an $$x \in \set{0,1}^\ell: t \sqsubseteq x \land f(x)=y$$ by definition. Such $$x$$ serves as a polynomially-bounded certificate for $$(1^\ell,t,y)$$. Also, the condition $$t \sqsubseteq x \land f(x)=y$$ is polynomial-time decidable.

Next we argue $$L \not\in \mathrm{P}$$. Suppose to the contrary that there exists a polynomial-time algorithm $$M$$ that decides $$L$$. We will use it as an oracle to construct an inverter $$I$$ that inverts $$f$$. The high-level idea is to exploit self-reducibility of the language $$L$$ to guide our inversion. As per convention, $$\epsilon$$ denotes the empty string.

![](./3-inverter.svg){:.centering}

The inverter first uses $$M$$ to detect the correct length $$\ell$$ of the preimage. Note that the length is polynomially bounded by the length of $$J.x$$ since $$f$$ is polynomially computable. After knowing $$\ell$$, the inverter incrementally searches for a preimage by revealing one bit at a time. Overall, $$I$$ runs in polynomial time and succeeds with non-negligible probability (in fact, 1), contradicting the fact that $$f$$ is a one-way function.

Combining the two parts we have P ≠ NP. ∎

With essentially no modification, the same argument also shows:

**Corollary 4.**
If one-way function exists, then RP ≠ NP.

We are now ready to prove Proposition 2. Note that it is implied by Corollary 4 and the lemma below.

**Lemma 5.**
If there is a $$?\textsf{NM}$$ secure scheme, then there exists a one-way function.

*Proof.*
Let $$\Sigma := (\gen,\sgn,\vrf)$$ be a $$?\textsf{NM}$$ secure scheme. It basically says that it is difficult to infer $$sk$$ from $$pk$$. Let's define a function $$f(r)$$ whose input $$r \in \set{0,1}^*$$ is understood as some "external random source". We run the algorithm `gen` using the provided random source $$r$$ and obtain a key pair $$(sk,pk)$$. The value $$f(r)$$ is defined as $$pk$$.

Because `gen` is a polynomial-time algorithm, the function $$f$$ is polynomial-time computable. It is also hard to invert; otherwise we could derive $$r$$ (and hence $$sk$$) from $$pk$$ and implement a $$?\textsf{NM}$$ attack with non-negligible success probability. The formal argument is left as an exercise. ∎

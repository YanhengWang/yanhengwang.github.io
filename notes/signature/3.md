---
layout: linear
date: 10 March 2022
title: One-Way Functions
preamble: |-
    \newcommand{\gen}{\texttt{gen}}
    \newcommand{\sgn}{\texttt{sgn}}
    \newcommand{\vrf}{\texttt{vrf}}
    \newcommand{\ECM}{\exists\textsf{CM}}
    \newcommand{\gcd}{\operatorname{gcd}}
returnPage: ./
---

As its name suggests, a one-way function is easy to evaluate but hard to invert. One-way functions are natural objects to consider since they help create our desired asymmetry in the resource demands of signer and forger. The formal definition goes as follows, again written in the language of attack protocol.

**Definition.**
Let $$f: \set{0,1}^* \to \set{0,1}^*$$ be a polynomial-time computable function. Consider the *inversion attack protocol*:

![](./3-inversion.svg){:.centering}

If for all polynomial-time randomised algorithms implementing $$I$$, the success probability $$\Pr(J \text{ returns true})$$ is negligible, then we call $$f$$ a *one-way function*. As usual, the "polynomial-time" and "negligible" are both measured with respect to $$k$$. It is possible that for some particular image $$y$$ the inverter could quickly answer a correct preimage, but the point here is that he cannot handle a general random image sampled from an exponentially large domain.

> People believe that one-way functions do exist.

There are multiple promising candidates and we will investigate two of them shortly. However, proofs are still out of current reach, especially in view of the following theorem:

**Theorem 3.**
If one-way functions exist, then P ≠ NP.

*Proof.*
Let $$f: \set{0,1}^* \to \set{0,1}^*$$ be a one-way function. For binary strings $$t,x \in \set{0,1}^*$$, we denote $$t \sqsubseteq x$$ if $$t$$ is a prefix of $$x$$. Consider the language

$$L := \set{(1^\ell,t,y) ~\middle\vert~ \exists x \in \set{0,1}^\ell: t \sqsubseteq x \land f(x)=y}.$$

It is easy to see $$L \in \mathrm{NP}$$. This is because $$(1^\ell,t,y) \in L$$ iff there exists an $$x \in \set{0,1}^\ell: t \sqsubseteq x \land f(x)=y$$ by definition. Such $$x$$ serves as a polynomially-bounded certificate for $$(1^\ell,t,y)$$. Also, the condition $$t \sqsubseteq x \land f(x)=y$$ is polynomial-time decidable.

Next we argue $$L \not\in \mathrm{P}$$. Suppose to the contrary that there exists a polynomial-time algorithm $$M$$ that decides $$L$$. We will use it as an oracle to construct an inverter $$I$$ that inverts $$f$$. The high-level idea is to exploit self-reducibility of the language $$L$$ to guide our inversion. As per convention, we use $$\epsilon$$ to denote the empty string.

![](./3-reduction.svg){:.centering}

The inverter first uses $$M$$ to detect the correct length $$\ell$$ of the preimage. Note that the length is polynomially bounded by the length of $$J.x$$ since $$f$$ is polynomially computable. After knowing $$\ell$$, the inverter incrementally searches for a preimage by revealing one bit at a time. Overall, $$I$$ runs in polynomial time and succeeds with non-negligible probability (in fact, 1), contradicting the fact that $$f$$ is a one-way function.

Combining the two parts we have P ≠ NP. ∎

With essentially no modification, the same argument also yields a strengthening:

**Corollary 4.**
If one-way function exists, then RP ≠ NP.

We are now ready to prove Proposition 2 from last time. Note that it is implied by Corollary 4 and the lemma below.

**Lemma 5.**
If there is a $$?\textsf{NM}$$ secure scheme, then there exists a one-way function.

*Proof.*
Let $$\Sigma := (\gen,\sgn,\vrf)$$ be a $$?\textsf{NM}$$ secure scheme. It basically says that it is difficult to infer $$sk$$ from $$pk$$. Let's define a function $$f(r)$$ whose input $$r \in \set{0,1}^*$$ is understood as some "external random source". We run the algorithm `gen` using the provided random source $$r$$ and obtain a key pair $$(sk,pk)$$. The value $$f(r)$$ is defined as $$pk$$.

Because `gen` is a polynomial-time algorithm, the function $$f$$ is polynomial-time computable. It is also hard to invert; otherwise we could derive $$r$$ (and hence $$sk$$) from $$pk$$ and implement a $$?\textsf{NM}$$ attack with non-negligible success probability. The formal argument is left as an exercise. ∎

In the remaining time we investigate two popular candidates of one-way functions.

# Candidate: Group Exponentiation

Let $$(G,\times)$$ be a finite group of order $$n$$, generated by element $$g \in G$$. That is, $$G = \set{g^\theta: \theta \in \Int_n }$$.

Consider the *exponentiation function* $$(\theta \in \Int_n) \mapsto (g^\theta \in G)$$. It is bijective and can be computed easily by the standard "square exponentiation" technique. But the inverse operation, also known as *discrete logarithm*, appears difficult for certain groups.

Here is a caveat. The words "easy" and "difficult" make no sense if the group is fixed -- everything would be constant time then. So we should instead consider a *sequence* of groups $$(G_1,\times), (G_2,\times), \dots$$, where group $$(G_k,\times)$$ is generated by $$g_k \in G_k$$ and has order $$n_k \to \infty$$ as $$k \to \infty$$. The "correct" definition of exponentiation function $$f$$ should be

$$ ((k \in \Nat), ~(\theta \in \Int_{n_k})) \mapsto (g_k^\theta \in G_k). $$

The computational complexity could thus be measured with respect to $$k$$. Note that the domains of the function do not perfectly align with the definition of one-way functions (where we require $$\set{0,1}^* \to \set{0,1}^*$$). This is not a fundamental issue since we could encode the input/output in binary strings anyway.

Modulo the encoding technicality, the exponentiation function $$f$$ appears to be one-way for certain (but not all) group families. An obviously bad choice would be $$(G_k,\times) := (\Int_k,+)$$ with generator $$g_k := 1$$. A traditional good choice is $$(G_k,\times) := (\Int_{p_k}^*, \times)$$ where $$p_k$$ is a prime growing with $$k$$. More recently, elliptic curve groups are drawing more attention because of implementation efficiency.

For easy reference, we isolate and restate the common belief about the exponentiation function:

> People believe that the exponentiation function is one-way for group family $$(\Int_{p_k}^*, \times)$$ with generator $$g_k$$. Namely, no inverter could succeed with non-negligible probability in the following attack
>
> ![](./3-dlog.svg){:.centering}


# Candidate: RSA Function

Let $$p, q$$ be distinct primes and $$n := p q$$. From basic number theory we have $$\phi(n) = (p-1)(q-1)$$ where $$\phi(\cdot)$$ is Euler's totient function. Choose an appropriate integer $$e > 2: \gcd(e,\phi(n)) = 1$$. The *RSA function* is the power function $$ (x \in \Int_n) \mapsto (x^e \in \Int_n)$$.

Again, to give sense to the hardness statements, we have to parameterise everything by $$k$$. A straightforward way would be parameterise $$p, q, e$$ as $$p_k, q_k, e_k$$ and define the RSA function as

$$ ((k \in \Nat),(x \in \Int_{n_k})) \mapsto (x^{e_k} \in \Int_{n_k}). $$

But this function is provably *not* one-way due to the "trapdoor" inside RSA! To be specific, because $$p_k, q_k, e_k$$ are fixed in advance, the inverter could easily compute $$\phi(n_k)$$ and an integer $$d_k := e_k^{-1} \pmod{\phi(n_k)}$$. By Fermat's little theorem we have $$(x^{e_k})^{d_k} = x^{e_k d_k} = x$$, thus the function is inverted efficiently.

There are intricate workarounds, but for the sake of readability we take a different approach. We slightly deviate from the definition of one-way functions and use a specialised version of inversion attack protocol:

> People believe that no inverter could succeed with non-negligible probability in the following attack
>
> ![](./3-RSA.svg){:.centering}

Here the $$p,q$$ are sampled randomly, so the inverter has no easy way of knowing the trapdoor. Besides, the image $$y$$ is sampled *directly*, whereas in the "standard" protocol $$y$$ is derived from a random preimage.
